diff --git a/time.txt b/time.txt
index ea70ce0..105d7d9 100644
--- a/time.txt
+++ b/time.txt
@@ -1 +1 @@
-72
+100
\ No newline at end of file
diff --git a/user/find.c b/user/find.c
index 648fd72..e719e6c 100644
--- a/user/find.c
+++ b/user/find.c
@@ -4,80 +4,84 @@
 #include "kernel/fs.h"
 #include "kernel/fcntl.h"
 
-char*
-fmtname(char *path)
+char* fmtname(char *path)
 {
-	char *p;
+  char *p;
 
-	// Find first character after last slash.
-	for(p=path+strlen(path); p >= path && *p != '/'; p--)
-		;
-	p++;
+  // Find first character after last slash.
+  for(p=path+strlen(path); p >= path && *p != '/'; p--)
+    ;
+  p++;
 
-	return p;
+  return p;
 }
 
-void
-find(char *path, char *targetname) 
-{
-	char buf[512], *p;
-	int fd;
-	struct dirent de;
-	struct stat st;
-
-	if (!strcmp(fmtname(path), targetname)) {
-		printf("%s\n", path);
-	}
+void find_all_files(char* dir_path, char* file_name){
+    int fd;
+    struct stat st;
 
-	if ((fd = open(path, O_RDONLY)) < 0) {
-		fprintf(2, "find: cannot open [%s], fd=%d\n", path, fd);
-		return;
-	}
+    if((fd = open(dir_path, O_RDONLY)) < 0){
+        printf("Cannot open %s\n", dir_path);
+        return;
+    }
 
-	if (fstat(fd, &st) < 0) {
-		fprintf(2, "find: cannot stat %s\n", path);
-		close(fd);
-		return;
-	}
+    if(fstat(fd, &st) < 0){
+        printf("Cannot stat %s\n", dir_path);
+        close(fd);
+        return;
+    }
 
-	if (st.type != T_DIR) {
-		close(fd);
-		return;
-	}
+    char buff[512];
+    strcpy(buff, dir_path);
+    char* p = buff + strlen(buff);
+    *p++ = '/';
+    
+    switch(st.type){
+    case T_DEVICE:
+    case T_FILE:
+    {
+        char* name = fmtname(dir_path);
+        if (strcmp(name, file_name) == 0){
+            printf("%s\n", dir_path);
+        }
+        break;
+    }
 
-	// st.type == T_DIR
-	
-	if (strlen(path) + 1 + DIRSIZ + 1 > sizeof buf) {
-		printf("find: path too long\n");
-		close(fd);
-		return;
-	}
-	strcpy(buf, path);
-	p = buf+strlen(buf);
-	*p++ = '/';
-	while (read(fd, &de, sizeof(de)) == sizeof(de)) {
-		if (de.inum == 0)
-			continue;
-		memmove(p, de.name, DIRSIZ);
-		p[DIRSIZ] = 0;
-		
-		if (!strcmp(de.name, ".") || !strcmp(de.name, ".."))
-			continue;
+    case T_DIR:
+    {
+        if(strlen(dir_path) + 1 + DIRSIZ + 1 > sizeof buff){
+            printf("Path too long\n");
+            break;
+        }
+        struct dirent de;
 
-		find(buf, targetname);
-	}
-	close(fd);
+        while(read(fd, &de, sizeof(de)) == sizeof(de)){
+            if(de.inum == 0)
+                continue;
+            if (strcmp(de.name, ".") == 0 || strcmp(de.name, "..") == 0)
+                continue;
+            memmove(p, de.name, strlen(de.name));
+            p[strlen(de.name)] = 0;
+            find_all_files(buff, file_name);
+        }
+        break;
+            }
+    }
+    close(fd);
 }
 
-int
-main(int argc, char *argv[])
-{
-	if(argc < 3){
-		fprintf(2, "usage: find path filename\n");
-		exit(1);
-	}
-
-	find(argv[1], argv[2]);
-
-	exit(0);
+int main(char argc, char* argv[]){
+    if (argc < 3){
+        fprintf(2,"Usage: find  [argv...]\n");
+        exit(1);
+    }
+    
+    if (argc > 3){
+        printf("Too much parameters!\n");
+        exit(1);
+    }
+    
+    //3 parameters
+    find_all_files(argv[1], argv[2]);
+    return 0;
 }
\ No newline at end of file
diff --git a/user/time.txt b/user/time.txt
deleted file mode 100644
index 9cd72aa..0000000
--- a/user/time.txt
+++ /dev/null
@@ -1 +0,0 @@
-72
\ No newline at end of file
diff --git a/user/xargs.c b/user/xargs.c
index b0fd557..2d8b7e7 100644
--- a/user/xargs.c
+++ b/user/xargs.c
@@ -8,7 +8,7 @@ char buffer[1024], character;
 char *p = buffer;
 char *v[MAXARG];
 int para, numberBlanks = 0, offset = 0;
-int maxArgs = 1; // Maximum number of arguments per command
+int maxArgs = 2; // Maximum number of arguments per command
 
 int main(int argc, char *argv[]) {
     // Check if the required command is provided as argument
